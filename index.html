<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tennis: Manual Serve</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        
        /* UI 레이어 */
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            gap: 60px;
            z-index: 10;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 15px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border: 3px solid #fff;
        }
        .score-box.player { border-bottom: 5px solid #1E90FF; }
        .score-box.ai { border-bottom: 5px solid #FF4500; }
        .score-label { font-size: 16px; font-weight: bold; color: #555; text-transform: uppercase; margin-bottom: 5px; }
        .score-num { font-size: 50px; font-weight: 900; color: #222; line-height: 1; }
        
        /* 메시지 오버레이 */
        #message-overlay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 20;
            width: 100%;
        }
        #main-msg {
            font-size: 100px;
            font-weight: 900;
            color: #ff3333;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px white, -2px -2px 0 white;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #sub-msg {
            font-size: 30px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* 서브 안내 메시지 */
        #serve-guide {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
            display: none;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* 조작법 안내 */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 16px;
            pointer-events: none;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        .key { display: inline-block; background: #fff; color: #333; padding: 2px 8px; border-radius: 5px; font-weight: bold; margin: 0 3px; box-shadow: 0 2px 0 #ccc; }
        .highlight { color: #FFD700; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="score-box player">
            <div class="score-label">Player</div>
            <div id="score-p" class="score-num">0</div>
        </div>
        <div class="score-box ai">
            <div class="score-label">Computer</div>
            <div id="score-a" class="score-num">0</div>
        </div>
    </div>

    <div id="message-overlay">
        <div id="main-msg">OUT!</div>
        <div id="sub-msg">Point to AI</div>
    </div>

    <div id="serve-guide">CLICK TO TOSS!</div>

    <div id="controls">
        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 이동 &nbsp;|&nbsp; 
        <span class="key">Click</span> 서브(토스+샷) / 스매시
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 씬 & 카메라 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 18, 42); 
        camera.lookAt(0, 0, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. 조명 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfffee0, 1.2);
        dirLight.position.set(-20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 3. 경기장 ---
        const COURT_W = 28;
        const COURT_H = 50;

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), new THREE.MeshPhongMaterial({ color: 0x55aa55 }));
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05;
        ground.receiveShadow = true;
        scene.add(ground);

        const court = new THREE.Mesh(new THREE.PlaneGeometry(COURT_W, COURT_H), new THREE.MeshPhongMaterial({ color: 0x4169E1 }));
        court.rotation.x = -Math.PI / 2;
        court.receiveShadow = true;
        scene.add(court);

        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const createLine = (w, h, x, z) => {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), lineMat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, 0.01, z);
            scene.add(mesh);
        };
        const lw = 0.4;
        createLine(COURT_W + lw, lw, 0, COURT_H/2);
        createLine(COURT_W + lw, lw, 0, -COURT_H/2);
        createLine(lw, COURT_H, COURT_W/2, 0);
        createLine(lw, COURT_H, -COURT_W/2, 0);
        createLine(COURT_W, lw, 0, 13);
        createLine(COURT_W, lw, 0, -13);
        createLine(lw, 26, 0, 0);

        // 관중석
        const spectators = [];
        function createStand(x, z, rotY) {
            const group = new THREE.Group();
            const standGeo = new THREE.BoxGeometry(50, 6, 12);
            const standMat = new THREE.MeshLambertMaterial({color: 0x666666});
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.y = 3;
            stand.castShadow = true;
            group.add(stand);

            for(let i=0; i<40; i++) {
                const c = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshLambertMaterial({color: c}));
                const px = (Math.random()-0.5) * 45;
                const pz = (Math.random()-0.5) * 8;
                const py = 6.5 + Math.random() * 0.5;
                head.position.set(px, py, pz);
                group.add(head);
                spectators.push({ mesh: head, baseY: py, speed: Math.random() * 0.1 + 0.05, offset: Math.random() * Math.PI * 2 });
            }
            group.position.set(x, 0, z);
            group.rotation.y = rotY;
            scene.add(group);
        }
        createStand(0, -40, 0);
        createStand(-32, 0, Math.PI/2);
        createStand(32, 0, -Math.PI/2);

        // 네트
        const netGroup = new THREE.Group();
        const netMesh = new THREE.Mesh(new THREE.BoxGeometry(COURT_W+2, 2.2, 0.1), new THREE.MeshLambertMaterial({color:0xffffff, transparent:true, opacity:0.6}));
        netMesh.position.y = 1.1;
        netGroup.add(netMesh);
        const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 3);
        const poleMat = new THREE.MeshPhongMaterial({color: 0x333});
        const p1 = new THREE.Mesh(poleGeo, poleMat); p1.position.set(-(COURT_W/2+1), 1.5, 0);
        const p2 = new THREE.Mesh(poleGeo, poleMat); p2.position.set((COURT_W/2+1), 1.5, 0);
        netGroup.add(p1, p2);
        scene.add(netGroup);


        // --- 4. 캐릭터 ---
        function createCharacter(color, isPlayer) {
            const group = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.0, 0.8), new THREE.MeshPhongMaterial({color: color}));
            body.position.y = 2.0;
            body.castShadow = true;
            group.add(body);
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), new THREE.MeshPhongMaterial({color: 0xffccaa}));
            head.position.y = 3.6; 
            head.castShadow = true;
            group.add(head);

            const armPivot = new THREE.Group();
            armPivot.position.set(isPlayer?0.9:-0.9, 2.8, 0);
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 0.35), new THREE.MeshPhongMaterial({color: 0xffccaa}));
            arm.position.y = -0.6;
            armPivot.add(arm);

            const racket = new THREE.Group();
            racket.position.y = -1.4;
            racket.rotation.x = Math.PI/2;
            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 8, 24), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            const net = new THREE.Mesh(new THREE.CircleGeometry(0.6, 16), new THREE.MeshBasicMaterial({color:0xccffcc, transparent:true, opacity:0.3, side:THREE.DoubleSide}));
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8), new THREE.MeshStandardMaterial({color:0x333}));
            handle.position.y = -0.6;
            handle.rotation.x = Math.PI/2;
            rim.add(net);
            racket.add(rim, handle);
            armPivot.add(racket);
            group.add(armPivot);

            armPivot.rotation.x = -0.5; 

            return {mesh: group, arm: armPivot, head: head, isPlayer: isPlayer, action: 'idle', animTime: 0};
        }

        const player = createCharacter(0x1E90FF, true);
        player.mesh.position.set(0, 0, 22);
        scene.add(player.mesh);

        const ai = createCharacter(0xFF4500, false);
        ai.mesh.position.set(0, 0, -22);
        ai.mesh.rotation.y = Math.PI;
        scene.add(ai.mesh);


        // --- 5. 공 & 이펙트 ---
        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), new THREE.MeshPhongMaterial({color: 0xccff00, emissive: 0x112200}));
        ball.castShadow = true;
        scene.add(ball);

        const trailSpheres = [];
        const MAX_TRAIL = 10;
        for(let i=0; i<MAX_TRAIL; i++) {
            const s = new THREE.Mesh(new THREE.SphereGeometry(0.3 - (i*0.02), 8, 8), 
                new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.6 - (i*0.05)}));
            s.visible = false;
            scene.add(s);
            trailSpheres.push(s);
        }
        let trailTimer = 0;

        function updateTrail(isSuper) {
            trailTimer++;
            if(trailTimer % 2 === 0) { 
                for(let i=MAX_TRAIL-1; i>0; i--) {
                    trailSpheres[i].position.copy(trailSpheres[i-1].position);
                    trailSpheres[i].visible = trailSpheres[i-1].visible;
                    trailSpheres[i].material.color.setHex(isSuper ? 0xFF4500 : 0xFFFF00);
                }
                trailSpheres[0].position.copy(ball.position);
                trailSpheres[0].visible = true;
            }
        }
        function clearTrail() {
            trailSpheres.forEach(s => s.visible = false);
        }

        const particles = [];
        const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const particleMat = new THREE.MeshBasicMaterial({color: 0xffffff});
        for(let i=0; i<20; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat.clone());
            p.visible = false;
            scene.add(p);
            particles.push({mesh: p, life: 0, vel: new THREE.Vector3()});
        }
        function spawnParticles(pos, color) {
            particles.forEach(p => {
                if(p.life <= 0) {
                    p.mesh.position.copy(pos);
                    p.mesh.material.color.setHex(color);
                    p.mesh.visible = true;
                    p.life = 1.0;
                    p.vel.set((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5);
                }
            });
        }

        // --- 6. 게임 로직 (서브 시스템 추가) ---
        let ballVel = new THREE.Vector3();
        let scoreP = 0;
        let scoreA = 0;
        
        // 상태: 'serve_hold', 'serve_toss', 'playing', 'end'
        let gameState = 'serve_hold'; 
        let currentServer = 'player'; // 현재 서브권을 가진 사람
        let lastHitter = null;
        let isSuperShot = false;

        const serveGuide = document.getElementById('serve-guide');
        const keys = {w:false, a:false, s:false, d:false};
        
        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
        
        // 마우스 클릭 이벤트 (서브 및 스매시)
        window.addEventListener('mousedown', () => {
            if (gameState === 'serve_hold' && currentServer === 'player') {
                // 1. 토스
                gameState = 'serve_toss';
                ballVel.set(0, 0.55, 0); // 위로 띄움
                serveGuide.innerText = "CLICK TO SMASH!";
                serveGuide.style.color = "#FF4444";
            } else if (gameState === 'serve_toss' && currentServer === 'player') {
                // 2. 서브 샷 (스매시)
                if (ball.position.y > 1.5) { // 너무 낮으면 못 침
                    swingRacket(player);
                    gameState = 'playing';
                    ballVel.set(0, 0.15, -0.9); // 강력한 서브
                    isSuperShot = true;
                    lastHitter = 'player';
                    serveGuide.style.display = 'none';
                    spawnParticles(ball.position, 0xFFA500);
                }
            } else {
                // 게임 중 스매시 트리거
                player.isSmashReady = true;
            }
        });
        
        window.addEventListener('mouseup', () => {
            player.isSmashReady = false;
        });

        function showMessage(main, sub, color='#fff') {
            const m = document.getElementById('main-msg');
            const s = document.getElementById('sub-msg');
            m.innerText = main; m.style.color = color;
            s.innerText = sub;
            m.style.opacity = 1; m.style.transform = "translate(-50%, -50%) scale(1.1)";
            s.style.opacity = 1;
            setTimeout(() => {
                m.style.opacity = 0; m.style.transform = "translate(-50%, -50%) scale(0.5)";
                s.style.opacity = 0;
            }, 1500);
        }

        // 서브 리셋 함수 (진 사람에게 서브권)
        function resetServe(loser) {
            gameState = 'serve_hold';
            currentServer = loser;
            
            // [수정됨] 캐릭터 상태 리셋 (얌전하게 복귀)
            player.action = 'idle';
            ai.action = 'idle';
            player.mesh.position.y = 0;
            ai.mesh.position.y = 0;
            player.mesh.rotation.x = 0;
            ai.mesh.rotation.x = 0;

            clearTrail();
            isSuperShot = false;
            ballVel.set(0,0,0);
            
            // 공 위치 초기화 (손에 잡기)
            updateBallHoldPos();

            // UI 안내
            if (currentServer === 'player') {
                serveGuide.innerText = "CLICK TO TOSS!";
                serveGuide.style.color = "#FFD700";
                serveGuide.style.display = 'block';
            } else {
                serveGuide.style.display = 'none';
                // AI 자동 서브 스케줄
                setTimeout(aiToss, 1000);
            }
        }

        function updateBallHoldPos() {
            if (gameState === 'serve_hold') {
                if (currentServer === 'player') {
                    ball.position.set(player.mesh.position.x + 0.8, player.mesh.position.y + 1.0, player.mesh.position.z - 0.5);
                } else {
                    ball.position.set(ai.mesh.position.x - 0.8, ai.mesh.position.y + 1.0, ai.mesh.position.z + 0.5);
                }
            }
        }

        // AI 자동 서브 로직
        function aiToss() {
            if (gameState !== 'serve_hold' || currentServer !== 'ai') return;
            gameState = 'serve_toss';
            ballVel.set(0, 0.55, 0); // AI 토스
            setTimeout(aiServeHit, 600); // 0.6초 후 타격
        }

        function aiServeHit() {
            if (gameState !== 'serve_toss') return;
            swingRacket(ai);
            gameState = 'playing';
            // AI 서브 방향 (약간 랜덤)
            const aimX = (Math.random() - 0.5) * 0.3;
            ballVel.set(aimX, 0.15, 0.7); // 플레이어 쪽으로
            lastHitter = 'ai';
        }

        // 초기 시작 (플레이어 서브)
        resetServe('player'); 

        // --- 7. 메인 루프 ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 플레이어 이동
            const speed = 0.35;
            if(keys.a) player.mesh.position.x -= speed;
            if(keys.d) player.mesh.position.x += speed;
            if(keys.w) player.mesh.position.z -= speed;
            if(keys.s) player.mesh.position.z += speed;
            
            player.mesh.position.x = THREE.MathUtils.clamp(player.mesh.position.x, -16, 16);
            player.mesh.position.z = THREE.MathUtils.clamp(player.mesh.position.z, 0, 35);

            // 서브 대기 중일 때 공이 플레이어 따라다님
            updateBallHoldPos();

            // 2. AI 이동
            if(gameState === 'playing' || (gameState.startsWith('serve') && currentServer === 'ai')) {
                let targetX = ai.mesh.position.x;
                let targetZ = -22;

                if (gameState === 'playing' && ballVel.z < 0) { // 공이 AI 쪽으로 올 때
                    targetX = ball.position.x;
                    if(ballVel.y < 0 && ball.position.z > -10) targetZ = -10;
                    else targetZ = -22; 
                } else if (gameState === 'serve_toss' && currentServer === 'ai') {
                    // AI 서브 토스 중 제자리
                } else {
                    targetX = 0; // 중앙 복귀
                }
                ai.mesh.position.x += (targetX - ai.mesh.position.x) * 0.12; 
                ai.mesh.position.z += (targetZ - ai.mesh.position.z) * 0.12;
            }

            // 3. 공 물리
            if(gameState === 'playing' || gameState === 'serve_toss') {
                ball.position.add(ballVel);
                ballVel.y -= 0.012; // 중력
                
                if (gameState === 'playing') {
                    ballVel.x *= 0.995;
                    ballVel.z *= 0.995;
                    updateTrail(isSuperShot);
                }

                // 바닥 충돌
                if(ball.position.y <= 0.35) {
                    ball.position.y = 0.35;
                    
                    if (gameState === 'serve_toss') {
                        // 서브 토스했는데 안 치고 땅에 떨어짐 -> 서브 실패(폴트) -> 상대 점수
                        // 편의상 다시 서브 기회 줌 (리셋)
                        gameState = 'serve_hold';
                        ballVel.set(0,0,0);
                        if(currentServer === 'player') {
                            serveGuide.innerText = "Try Again!";
                            setTimeout(() => { serveGuide.innerText = "CLICK TO TOSS!"; }, 1000);
                        } else {
                            resetServe('ai'); // AI 실수 재시도
                        }
                    } else {
                        // Playing 상태
                        spawnParticles(ball.position, 0xcccccc);
                        
                        // 라인 판정
                        const inX = Math.abs(ball.position.x) <= COURT_W/2 + 0.5;
                        const inZ = Math.abs(ball.position.z) <= COURT_H/2 + 0.5;
                        
                        if(!inX || !inZ) { // OUT
                            handleScore(lastHitter === 'player' ? 'ai' : 'player', "OUT!");
                        } else { // IN
                            ballVel.y *= -0.85; 
                            isSuperShot = false;
                        }
                    }
                }

                // 네트 충돌
                if(Math.abs(ball.position.z) < 1 && ball.position.y < 2.2) {
                    ballVel.z *= -0.5;
                    ballVel.x *= 0.5;
                    isSuperShot = false;
                }
            }

            // 4. 타격 판정 (게임 중)
            if (gameState === 'playing') {
                const hitDist = 3.0;
                // Player Hit
                if(ballVel.z > 0 && ball.position.z > 0) {
                    if(ball.position.distanceTo(player.mesh.position) < hitDist) {
                        swingRacket(player);
                        ballVel.z *= -1;
                        
                        if(player.isSmashReady) {
                            ballVel.z = -0.9; ballVel.y = 0.15; isSuperShot = true;
                            spawnParticles(ball.position, 0xFFA500);
                        } else {
                            ballVel.z = -0.6; ballVel.y = 0.45; isSuperShot = false;
                        }
                        ballVel.x = (ball.position.x - player.mesh.position.x) * 0.3;
                        lastHitter = 'player';
                    }
                }
                // AI Hit
                if(ballVel.z < 0 && ball.position.z < 0) {
                    if(ball.position.distanceTo(ai.mesh.position) < hitDist) {
                        swingRacket(ai);
                        ballVel.z *= -1;
                        if(Math.random() > 0.7) { ballVel.z = 0.85; ballVel.y = 0.2; isSuperShot = true; }
                        else { ballVel.z = 0.6; ballVel.y = 0.45; isSuperShot = false; }
                        ballVel.x = (ball.position.x - ai.mesh.position.x) * 0.3;
                        lastHitter = 'ai';
                    }
                }

                // 5. 골 판정
                if(ball.position.z > 35) handleScore('ai', "GOAL!"); // AI 득점
                else if(ball.position.z < -35) handleScore('player', "NICE SHOT!"); // Player 득점
            }

            updateCharacter(player);
            updateCharacter(ai);
            updateParticles();
            updateSpectators();
            renderer.render(scene, camera);
        }

        // 점수 처리 및 패자 서브 설정
        function handleScore(winner, msg) {
            gameState = 'end';
            if (winner === 'ai') {
                scoreA++; document.getElementById('score-a').innerText = scoreA;
                showMessage(msg, "AI Scores", "#FF4444");
                ai.action = 'happy'; player.action = 'sad';
                // 플레이어가 졌으므로 플레이어 서브
                setTimeout(() => resetServe('player'), 2000);
            } else {
                scoreP++; document.getElementById('score-p').innerText = scoreP;
                showMessage(msg, "Player Scores", "#4444FF");
                ai.action = 'sad'; player.action = 'happy';
                // AI가 졌으므로 AI 서브
                setTimeout(() => resetServe('ai'), 2000);
            }
        }

        function swingRacket(char) {
            let f = 0;
            const anim = () => {
                if(f < 8) { char.arm.rotation.x -= 0.4; f++; requestAnimationFrame(anim); }
                else char.arm.rotation.x = -0.5;
            }
            anim();
        }

        function updateCharacter(c) {
            c.animTime += 0.1;
            if(c.action === 'happy') {
                c.mesh.position.y = Math.abs(Math.sin(c.animTime*5)) * 1.5;
                c.arm.rotation.z = Math.sin(c.animTime*10);
            } else if(c.action === 'sad') {
                c.mesh.rotation.x = 0.5;
            } else {
                // 서브가 아니고 게임중이거나 대기일때만 y축 0
                if (gameState !== 'serve_hold') c.mesh.position.y = 0; 
                c.mesh.rotation.x = 0; c.arm.rotation.z = 0;
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                if(p.life > 0) {
                    p.life -= 0.05;
                    p.mesh.position.add(p.vel);
                    p.mesh.scale.setScalar(p.life);
                    p.mesh.visible = true;
                } else p.mesh.visible = false;
            });
        }

        function updateSpectators() {
            const time = Date.now() * 0.005;
            spectators.forEach(s => {
                s.mesh.position.y = s.baseY + Math.abs(Math.sin(time * s.speed + s.offset)) * 0.5;
            });
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
