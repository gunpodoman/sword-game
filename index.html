<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Tennis: Easy Visuals</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #87CEEB; 
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; /* 모바일 제스처 방지 */
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* UI 레이어 */
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 10;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 10px 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 2px solid #fff;
            min-width: 60px;
        }
        .score-box.player { border-bottom: 4px solid #1E90FF; }
        .score-box.ai { border-bottom: 4px solid #FF4500; }
        .score-label { font-size: 12px; font-weight: bold; color: #555; text-transform: uppercase; margin-bottom: 2px; }
        .score-num { font-size: 36px; font-weight: 900; color: #222; line-height: 1; }
        
        /* 메시지 오버레이 */
        #message-overlay {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 20;
            width: 100%;
        }
        #main-msg {
            font-size: 60px;
            font-weight: 900;
            color: #ff3333;
            text-transform: uppercase;
            text-shadow: 3px 3px 0px white, -1px -1px 0 white;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #sub-msg {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* 서브 안내 메시지 */
        #serve-guide {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
            display: none;
            width: 100%;
            text-align: center;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* 모바일 컨트롤러 */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            z-index: 50;
            pointer-events: none; /* 영역 전체는 통과, 버튼만 터치 가능 */
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        /* 조이스틱 영역 */
        #joystick-area {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: relative;
            pointer-events: auto; /* 터치 활성화 */
            backdrop-filter: blur(2px);
        }
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            pointer-events: none;
        }

        /* 액션 버튼 */
        #action-btn {
            width: 100px;
            height: 100px;
            background: rgba(255, 69, 0, 0.6); /* 오렌지색 반투명 */
            border: 4px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s, background 0.1s;
        }
        #action-btn:active {
            transform: scale(0.95);
            background: rgba(255, 69, 0, 0.8);
        }

        /* PC용 안내 (모바일에서는 숨김 가능) */
        #pc-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            #mobile-controls { padding: 0 20px; bottom: 30px; }
            #main-msg { font-size: 40px; }
            #pc-controls { display: none; }
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="score-box player">
            <div class="score-label">Player</div>
            <div id="score-p" class="score-num">0</div>
        </div>
        <div class="score-box ai">
            <div class="score-label">Com</div>
            <div id="score-a" class="score-num">0</div>
        </div>
    </div>

    <div id="message-overlay">
        <div id="main-msg">OUT!</div>
        <div id="sub-msg">Point to AI</div>
    </div>

    <div id="serve-guide">TAP BUTTON TO TOSS!</div>

    <div id="pc-controls">WASD: Move / Click: Swing</div>

    <!-- 모바일 컨트롤러 -->
    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-knob"></div>
        </div>
        <div id="action-btn">HIT</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 씬 & 카메라 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 19, 43); // 모바일 시야 확보를 위해 약간 더 뒤로
        camera.lookAt(0, 0, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // 픽셀 비율 최적화 (모바일 성능)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. 조명 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfffee0, 1.2);
        dirLight.position.set(-20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        scene.add(dirLight);

        // --- 3. 경기장 ---
        const COURT_W = 28;
        const COURT_H = 50;

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), new THREE.MeshPhongMaterial({ color: 0x55aa55 }));
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05;
        ground.receiveShadow = true;
        scene.add(ground);

        const court = new THREE.Mesh(new THREE.PlaneGeometry(COURT_W, COURT_H), new THREE.MeshPhongMaterial({ color: 0x4169E1 }));
        court.rotation.x = -Math.PI / 2;
        court.receiveShadow = true;
        scene.add(court);

        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const createLine = (w, h, x, z) => {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), lineMat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, 0.01, z);
            scene.add(mesh);
        };
        const lw = 0.4;
        createLine(COURT_W + lw, lw, 0, COURT_H/2);
        createLine(COURT_W + lw, lw, 0, -COURT_H/2);
        createLine(lw, COURT_H, COURT_W/2, 0);
        createLine(lw, COURT_H, -COURT_W/2, 0);
        createLine(COURT_W, lw, 0, 13);
        createLine(COURT_W, lw, 0, -13);
        createLine(lw, 26, 0, 0);

        // 관중석
        const spectators = [];
        function createStand(x, z, rotY) {
            const group = new THREE.Group();
            const standGeo = new THREE.BoxGeometry(50, 6, 12);
            const standMat = new THREE.MeshLambertMaterial({color: 0x666666});
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.y = 3;
            stand.castShadow = true;
            group.add(stand);

            const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            for(let i=0; i<30; i++) {
                const c = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                const head = new THREE.Mesh(headGeo, new THREE.MeshLambertMaterial({color: c}));
                const px = (Math.random()-0.5) * 45;
                const pz = (Math.random()-0.5) * 8;
                const py = 6.5 + Math.random() * 0.5;
                head.position.set(px, py, pz);
                group.add(head);
                spectators.push({ mesh: head, baseY: py, speed: Math.random() * 0.1 + 0.05, offset: Math.random() * Math.PI * 2 });
            }
            group.position.set(x, 0, z);
            group.rotation.y = rotY;
            scene.add(group);
        }
        createStand(0, -42, 0);
        createStand(-35, 0, Math.PI/2);
        createStand(35, 0, -Math.PI/2);

        // 네트
        const netGroup = new THREE.Group();
        const netMesh = new THREE.Mesh(new THREE.BoxGeometry(COURT_W+2, 2.2, 0.1), new THREE.MeshLambertMaterial({color:0xffffff, transparent:true, opacity:0.6}));
        netMesh.position.y = 1.1;
        netGroup.add(netMesh);
        const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 3);
        const poleMat = new THREE.MeshPhongMaterial({color: 0x333});
        const p1 = new THREE.Mesh(poleGeo, poleMat); p1.position.set(-(COURT_W/2+1), 1.5, 0);
        const p2 = new THREE.Mesh(poleGeo, poleMat); p2.position.set((COURT_W/2+1), 1.5, 0);
        netGroup.add(p1, p2);
        scene.add(netGroup);

        // --- 4. 캐릭터 ---
        function createCharacter(color, isPlayer) {
            const group = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.0, 0.8), new THREE.MeshPhongMaterial({color: color}));
            body.position.y = 2.0;
            body.castShadow = true;
            group.add(body);
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), new THREE.MeshPhongMaterial({color: 0xffccaa}));
            head.position.y = 3.6; 
            head.castShadow = true;
            group.add(head);

            const armPivot = new THREE.Group();
            armPivot.position.set(isPlayer?0.9:-0.9, 2.8, 0);
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 0.35), new THREE.MeshPhongMaterial({color: 0xffccaa}));
            arm.position.y = -0.6;
            armPivot.add(arm);

            const racket = new THREE.Group();
            racket.position.y = -1.4;
            racket.rotation.x = Math.PI/2;
            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 8, 24), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            const net = new THREE.Mesh(new THREE.CircleGeometry(0.6, 16), new THREE.MeshBasicMaterial({color:0xccffcc, transparent:true, opacity:0.3, side:THREE.DoubleSide}));
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8), new THREE.MeshStandardMaterial({color:0x333}));
            handle.position.y = -0.6;
            handle.rotation.x = Math.PI/2;
            rim.add(net);
            racket.add(rim, handle);
            armPivot.add(racket);
            group.add(armPivot);

            armPivot.rotation.x = -0.5; 

            return {mesh: group, arm: armPivot, head: head, isPlayer: isPlayer, action: 'idle', animTime: 0, isSmashReady: false};
        }

        const player = createCharacter(0x1E90FF, true);
        player.mesh.position.set(0, 0, 22);
        scene.add(player.mesh);

        const ai = createCharacter(0xFF4500, false);
        ai.mesh.position.set(0, 0, -22);
        ai.mesh.rotation.y = Math.PI;
        scene.add(ai.mesh);

        // --- 5. 공 & 이펙트 & 가이드 ---
        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), new THREE.MeshPhongMaterial({color: 0xccff00, emissive: 0x112200}));
        ball.castShadow = true;
        scene.add(ball);

        // [시각 보조 강화] 공 위치 추적 가이드 (그림자 + 링)
        const ballTracker = new THREE.Group();
        scene.add(ballTracker);

        // 1. 진한 그림자 (위치 파악용)
        const shadowMesh = new THREE.Mesh(
            new THREE.CircleGeometry(0.45, 32),
            new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.5, transparent: true })
        );
        shadowMesh.rotation.x = -Math.PI / 2;
        shadowMesh.position.y = 0.02;
        ballTracker.add(shadowMesh);

        // 2. 가이드 링 (노란색 테두리 - 시인성 확보)
        const ringMesh = new THREE.Mesh(
            new THREE.RingGeometry(0.45, 0.6, 32),
            new THREE.MeshBasicMaterial({ color: 0xFFFF00, opacity: 0.8, transparent: true, side: THREE.DoubleSide })
        );
        ringMesh.rotation.x = -Math.PI / 2;
        ringMesh.position.y = 0.03; // 그림자보다 살짝 위
        ballTracker.add(ringMesh);

        const trailSpheres = [];
        const MAX_TRAIL = 12; 
        for(let i=0; i<MAX_TRAIL; i++) {
            const s = new THREE.Mesh(new THREE.SphereGeometry(0.3 - (i*0.02), 8, 8), 
                new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.6 - (i*0.05)}));
            s.visible = false;
            scene.add(s);
            trailSpheres.push(s);
        }
        let trailTimer = 0;

        function updateTrail(isSuper) {
            trailTimer++;
            if(trailTimer % 2 === 0) { 
                for(let i=MAX_TRAIL-1; i>0; i--) {
                    trailSpheres[i].position.copy(trailSpheres[i-1].position);
                    trailSpheres[i].visible = trailSpheres[i-1].visible;
                    trailSpheres[i].material.color.setHex(isSuper ? 0xFF4500 : 0xFFFF00);
                }
                trailSpheres[0].position.copy(ball.position);
                trailSpheres[0].visible = true;
            }
        }
        function clearTrail() {
            trailSpheres.forEach(s => s.visible = false);
        }

        const particles = [];
        const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const particleMat = new THREE.MeshBasicMaterial({color: 0xffffff});
        for(let i=0; i<25; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat.clone());
            p.visible = false;
            scene.add(p);
            particles.push({mesh: p, life: 0, vel: new THREE.Vector3()});
        }
        function spawnParticles(pos, color) {
            particles.forEach(p => {
                if(p.life <= 0) {
                    p.mesh.position.copy(pos);
                    p.mesh.material.color.setHex(color);
                    p.mesh.visible = true;
                    p.life = 1.0;
                    p.vel.set((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5);
                }
            });
        }

        // --- 6. 입력 처리 ---
        const inputState = { x: 0, z: 0, action: false };
        const keys = { w:false, a:false, s:false, d:false };

        window.addEventListener('keydown', e => { 
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true; 
        });
        window.addEventListener('keyup', e => { 
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false; 
        });

        const joystickArea = document.getElementById('joystick-area');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joyStartX = 0, joyStartY = 0;

        joystickArea.addEventListener('touchstart', (e) => {
            joystickActive = true;
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            joyStartX = rect.left + rect.width / 2;
            joyStartY = rect.top + rect.height / 2;
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive: false});

        joystickArea.addEventListener('touchmove', (e) => {
            if(joystickActive) {
                e.preventDefault(); 
                updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        const endJoystick = () => {
            joystickActive = false;
            inputState.x = 0;
            inputState.z = 0;
            joystickKnob.style.transform = `translate(-50%, -50%)`;
        };
        joystickArea.addEventListener('touchend', endJoystick);
        joystickArea.addEventListener('touchcancel', endJoystick);

        function updateJoystick(clientX, clientY) {
            const maxDist = 40; 
            let dx = clientX - joyStartX;
            let dy = clientY - joyStartY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > maxDist) {
                const ratio = maxDist / dist;
                dx *= ratio;
                dy *= ratio;
            }

            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            inputState.x = dx / maxDist;
            inputState.z = dy / maxDist;
        }

        function handleActionStart() {
            triggerAction();
        }
        function handleActionEnd() {
            player.isSmashReady = false;
        }

        const actionBtn = document.getElementById('action-btn');
        actionBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleActionStart(); }, {passive: false});
        actionBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleActionEnd(); });
        
        window.addEventListener('mousedown', handleActionStart);
        window.addEventListener('mouseup', handleActionEnd);

        // --- 7. 게임 로직 (속도 조절) ---
        let ballVel = new THREE.Vector3();
        let scoreP = 0;
        let scoreA = 0;
        let gameState = 'serve_hold'; 
        let currentServer = 'player';
        let lastHitter = null;
        let isSuperShot = false;

        const serveGuide = document.getElementById('serve-guide');

        function triggerAction() {
            if (gameState === 'serve_hold' && currentServer === 'player') {
                gameState = 'serve_toss';
                ballVel.set(0, 0.55, 0);
                serveGuide.innerText = "TAP TO SMASH!";
                serveGuide.style.color = "#FF4444";
            } else if (gameState === 'serve_toss' && currentServer === 'player') {
                if (ball.position.y > 0.8) { 
                    swingRacket(player);
                    gameState = 'playing';
                    // [속도 하향] 플레이어 서브 속도 감소 (-0.85 -> -0.7)
                    ballVel.set(0, 0.15, -0.7); 
                    isSuperShot = true;
                    lastHitter = 'player';
                    serveGuide.style.display = 'none';
                    spawnParticles(ball.position, 0xFFA500);
                }
            } else {
                player.isSmashReady = true;
                checkPlayerHit(true);
            }
        }

        function showMessage(main, sub, color='#fff') {
            const m = document.getElementById('main-msg');
            const s = document.getElementById('sub-msg');
            m.innerText = main; m.style.color = color;
            s.innerText = sub;
            m.style.opacity = 1; m.style.transform = "translate(-50%, -50%) scale(1.1)";
            s.style.opacity = 1;
            setTimeout(() => {
                m.style.opacity = 0; m.style.transform = "translate(-50%, -50%) scale(0.5)";
                s.style.opacity = 0;
            }, 1500);
        }

        function resetServe(loser) {
            gameState = 'serve_hold';
            currentServer = loser;
            
            player.action = 'idle';
            ai.action = 'idle';
            player.mesh.position.y = 0;
            ai.mesh.position.y = 0;
            player.mesh.rotation.x = 0;
            ai.mesh.rotation.x = 0;

            clearTrail();
            isSuperShot = false;
            ballVel.set(0,0,0);
            updateBallHoldPos();

            if (currentServer === 'player') {
                serveGuide.innerText = "TAP BUTTON TO TOSS!";
                serveGuide.style.color = "#FFD700";
                serveGuide.style.display = 'block';
            } else {
                serveGuide.style.display = 'none';
                setTimeout(aiToss, 1000);
            }
        }

        function updateBallHoldPos() {
            if (gameState === 'serve_hold') {
                if (currentServer === 'player') {
                    ball.position.set(player.mesh.position.x + 0.8, player.mesh.position.y + 1.0, player.mesh.position.z - 0.5);
                } else {
                    ball.position.set(ai.mesh.position.x - 0.8, ai.mesh.position.y + 1.0, ai.mesh.position.z + 0.5);
                }
            }
        }

        function aiToss() {
            if (gameState !== 'serve_hold' || currentServer !== 'ai') return;
            gameState = 'serve_toss';
            ballVel.set(0, 0.55, 0);
            setTimeout(aiServeHit, 600);
        }

        function aiServeHit() {
            if (gameState !== 'serve_toss') return;
            swingRacket(ai);
            gameState = 'playing';
            const aimX = (Math.random() - 0.5) * 0.3;
            // [속도 하향] AI 서브 속도 감소 (0.65 -> 0.52)
            ballVel.set(aimX, 0.15, 0.52);
            lastHitter = 'ai';
        }

        resetServe('player'); 

        function checkPlayerHit(forcedSwing = false) {
            if (gameState !== 'playing') return;
            
            if (ballVel.z > 0) { 
                let success = false;
                const dist = ball.position.distanceTo(player.mesh.position);
                const zDist = Math.abs(ball.position.z - player.mesh.position.z);

                if (forcedSwing) {
                    if (dist < 6.5 && zDist < 8.0) success = true;
                } else {
                    if (dist < 4.5) success = true;
                }

                if (success) {
                    swingRacket(player);
                    ballVel.z *= -1; 
                    
                    // [속도 하향] 플레이어 타구 속도 감소
                    if (Math.abs(ballVel.z) < 0.5) ballVel.z = -0.55; // 최소 속도 보정

                    if(forcedSwing || player.isSmashReady) {
                        ballVel.y = 0.2;
                        ballVel.z = -0.75; // 스매시 속도 감소 (-0.95 -> -0.75)
                        isSuperShot = true;
                        spawnParticles(ball.position, 0xFFA500);
                    } else {
                        ballVel.y = 0.45; 
                        ballVel.z = Math.max(ballVel.z, -0.55); // 일반 타격도 느리게
                        isSuperShot = false;
                    }

                    let aimX = 0;
                    const distToBall = ball.position.distanceTo(player.mesh.position);
                    if (distToBall > 5.0) {
                        aimX = (inputState.x * 0.3) + ((Math.random()-0.5) * 0.2); 
                        if (ball.position.x > 10) aimX -= 0.15;
                        if (ball.position.x < -10) aimX += 0.15;
                    } else {
                        aimX = (ball.position.x - player.mesh.position.x) * 0.3;
                        if (inputState.x !== 0) aimX += inputState.x * 0.2;
                    }
                    ballVel.x = aimX;
                    
                    lastHitter = 'player';
                    player.isSmashReady = false; 
                }
            }
        }

        // --- 8. 메인 루프 ---
        function animate() {
            requestAnimationFrame(animate);

            // [속도 하향] 플레이어 이동 속도 감소 (0.4 -> 0.32)
            let moveX = 0;
            let moveZ = 0;
            const speed = 0.32;

            if(keys.a) moveX -= 1;
            if(keys.d) moveX += 1;
            if(keys.w) moveZ -= 1;
            if(keys.s) moveZ += 1;

            moveX += inputState.x;
            moveZ += inputState.z;

            player.mesh.position.x += moveX * speed;
            player.mesh.position.z += moveZ * speed;
            
            player.mesh.position.x = THREE.MathUtils.clamp(player.mesh.position.x, -16, 16);
            player.mesh.position.z = THREE.MathUtils.clamp(player.mesh.position.z, 0, 35);

            updateBallHoldPos();

            if(gameState === 'playing' || (gameState.startsWith('serve') && currentServer === 'ai')) {
                let targetX = ai.mesh.position.x;
                let targetZ = -22;

                if (gameState === 'playing' && ballVel.z < 0) { 
                    targetX = ball.position.x;
                    if(ballVel.y < 0 && ball.position.z > -10) targetZ = -10;
                    else targetZ = -22; 
                } else if (gameState === 'serve_toss' && currentServer === 'ai') {
                } else {
                    targetX = 0; 
                }
                ai.mesh.position.x += (targetX - ai.mesh.position.x) * 0.10; 
                ai.mesh.position.z += (targetZ - ai.mesh.position.z) * 0.10;
            }

            if(gameState === 'playing' || gameState === 'serve_toss') {
                ball.position.add(ballVel);
                ballVel.y -= 0.012; 
                
                // [시각 보조 업데이트] 볼 트래커 위치 동기화
                ballTracker.visible = true;
                ballTracker.position.set(ball.position.x, 0, ball.position.z);
                
                // 높이에 따라 투명도/크기 조절 (높을수록 연해지지만 링은 잘 보이게)
                const heightFactor = Math.min(ball.position.y / 8, 1.0);
                shadowMesh.material.opacity = 0.6 * (1 - heightFactor * 0.5); // 그림자는 흐려짐
                ringMesh.material.opacity = 0.8 * (1 - heightFactor * 0.3);   // 링은 비교적 선명

                if (gameState === 'playing') {
                    ballVel.x *= 0.995;
                    ballVel.z *= 0.995;
                    updateTrail(isSuperShot);
                }

                if(ball.position.y <= 0.35) {
                    ball.position.y = 0.35;
                    
                    if (gameState === 'serve_toss') {
                        gameState = 'serve_hold';
                        ballVel.set(0,0,0);
                        if(currentServer === 'player') {
                            serveGuide.innerText = "Try Again!";
                            setTimeout(() => { serveGuide.innerText = "TAP TO TOSS!"; }, 1000);
                        } else {
                            resetServe('ai');
                        }
                    } else {
                        spawnParticles(ball.position, 0xcccccc);
                        
                        const inX = Math.abs(ball.position.x) <= COURT_W/2 + 0.5;
                        const inZ = Math.abs(ball.position.z) <= COURT_H/2 + 0.5;
                        
                        if(!inX || !inZ) { 
                            handleScore(lastHitter === 'player' ? 'ai' : 'player', "OUT!");
                        } else { 
                            ballVel.y *= -0.8; 
                            isSuperShot = false;
                        }
                    }
                }

                if(Math.abs(ball.position.z) < 1 && ball.position.y < 2.2) {
                    ballVel.z *= -0.5;
                    ballVel.x *= 0.5;
                    isSuperShot = false;
                }
            } else {
                ballTracker.visible = false;
            }

            if (gameState === 'playing') {
                const hitDist = 4.0; 
                if(ballVel.z < 0 && ball.position.z < 0) {
                    if(ball.position.distanceTo(ai.mesh.position) < hitDist) {
                        swingRacket(ai);
                        ballVel.z *= -1;
                        
                        // [속도 하향] AI 반격 속도 감소
                        if(Math.random() > 0.6) { 
                            ballVel.z = 0.65; // (0.8 -> 0.65)
                            ballVel.y = 0.2; 
                            isSuperShot = true; 
                        } else { 
                            ballVel.z = 0.5; // (0.6 -> 0.5)
                            ballVel.y = 0.45; 
                            isSuperShot = false; 
                        }
                        ballVel.x = (ball.position.x - ai.mesh.position.x) * 0.3;
                        lastHitter = 'ai';
                    }
                }

                if(ball.position.z > 35) handleScore('ai', "GOAL!"); 
                else if(ball.position.z < -35) handleScore('player', "NICE SHOT!");
            }

            updateCharacter(player);
            updateCharacter(ai);
            updateParticles();
            renderer.render(scene, camera);
        }

        function handleScore(winner, msg) {
            gameState = 'end';
            if (winner === 'ai') {
                scoreA++; document.getElementById('score-a').innerText = scoreA;
                showMessage(msg, "AI Point", "#FF4444");
                ai.action = 'happy'; player.action = 'sad';
                setTimeout(() => resetServe('player'), 2000);
            } else {
                scoreP++; document.getElementById('score-p').innerText = scoreP;
                showMessage(msg, "Player Point", "#4444FF");
                ai.action = 'sad'; player.action = 'happy';
                setTimeout(() => resetServe('ai'), 2000);
            }
        }

        function swingRacket(char) {
            let f = 0;
            const anim = () => {
                if(f < 6) { 
                    char.arm.rotation.x -= 0.5; 
                    f++; 
                    requestAnimationFrame(anim); 
                } else {
                    char.arm.rotation.x = -0.5;
                }
            }
            anim();
        }

        function updateCharacter(c) {
            c.animTime += 0.1;
            if(c.action === 'happy') {
                c.mesh.position.y = Math.abs(Math.sin(c.animTime*5)) * 1.5;
                c.arm.rotation.z = Math.sin(c.animTime*10);
            } else if(c.action === 'sad') {
                c.mesh.rotation.x = 0.5;
            } else {
                if (gameState !== 'serve_hold') c.mesh.position.y = 0; 
                c.mesh.rotation.x = 0; c.arm.rotation.z = 0;
                
                if(c.isPlayer && (inputState.x !== 0 || keys.a || keys.d)) {
                   c.mesh.rotation.z = -(inputState.x || (keys.a?-1:1)) * 0.1;
                   c.mesh.rotation.y = -(inputState.x || (keys.a?-1:1)) * 0.2;
                } else {
                   c.mesh.rotation.z = 0;
                   if(c.isPlayer) c.mesh.rotation.y = 0;
                }
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                if(p.life > 0) {
                    p.life -= 0.05;
                    p.mesh.position.add(p.vel);
                    p.mesh.scale.setScalar(p.life);
                    p.mesh.visible = true;
                } else p.mesh.visible = false;
            });
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
